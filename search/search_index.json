{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"SequenceHome/","title":"Introduction","text":"<p>As indicated by the name, sequence diagrams are meant to describe and document the temporal operation of a system. The diagram is meant to visually explain structural and functional aspects of systems that rely on message passing between objects  such as object oriented and distributed systems.</p>"},{"location":"SequenceHome/#the-guidelines","title":"The Guidelines","text":""},{"location":"SequenceHome/#sequence-layout","title":"Sequence Layout","text":""},{"location":"SequenceHome/#ordering-sequences","title":"Ordering Sequences","text":"<p>Sequences should follow a left-to-right, top-to-bottom arrangement. This sequence is not always strictly possible since some objects communicate bidirectionally or asynchronously across their lifespans.</p>"},{"location":"SequenceHome/#lifeline-layers","title":"Lifeline Layers","text":"<p>The vertical position of the lifelines can be offset to indicate system layers. The system layers indicate both physical and logical arrangements of related lifelines and can make the grouping of related lifelines more apparent.</p>"},{"location":"SequenceHome/#use-prose-descriptions","title":"Use Prose Descriptions","text":"<p>A common issue with Sequence diagrams is that sometimes the overarching purpose of the process or workflow is lost in the details of specific objects passing messages which sometimes includes loops or asynchronous processing. Adding a descriptive prose outline on the left hand side of the diagram is useful to clarify the subprocess that is being illustrated (c.f. Ambler (2005) fig. 30)</p>"},{"location":"SequenceHome/#place-initiators-on-the-left","title":"Place Initiators on the Left","text":"<p>The process or object that initiates communication should be placed to the left of the receiver.</p>"},{"location":"SequenceHome/#place-reactorsreceivers-on-the-right","title":"Place Reactors/Receivers on the Right","text":"<p>The process or object that receives communication should be placed to the right of the initiator.</p>"},{"location":"SequenceHome/#avoid-activation-boxes","title":"Avoid Activation Boxes","text":"<p>Use activation boxes sparingly. If it is important for the audience of the diagram to consider processing time then indicating the active and inactive portions of each lifeline is OK. However, if it does not bring clarity they may be omitted. The more important feature to highlight is the sequence and direction of message passing. Thus arrange the diagram in a way that makes the timing of  the sending and receipt of these messages clear.</p>"},{"location":"SequenceHome/#use-consistent-stereotypes","title":"Use Consistent Stereotypes","text":"<p>Labels for lifelines are only weakly standardized and mostly uses by convention. Be sure to label objects consistently. Make sure to distinguish between real-world actors and classes that represent those actors.</p>"},{"location":"SequenceHome/#general-layout-considerations","title":"General Layout Considerations","text":"<p>Including an explicit depiction of object lifecycles such as object destruction or other explicit resource management can introduce clutter in the diagrams without adding clarity to the presentation of the sequence of actions and data flows. Avoid these especially when the target implementation language does not rely on explicit destruction (e.g. garbage collected or managed code).</p> <p>In addition to the best practices discussed here, certain publication requirements may need to be accommodated depending on the medium of publication or organizational standards. Additional additional formatting can be made compliant as follows.</p>"},{"location":"SequenceHome/#headers-and-footers","title":"Headers and Footers","text":"<p>The diagram should be able to accommodate headers and footers.  The text of the headers and footers should be centered. The color and size of the footer should be configurable to comply with external publication requirements.</p>"},{"location":"SequenceHome/#left-right-margins","title":"Left &amp; Right Margins","text":"<p>The left margin should be reserved for additional explanatory notes &amp; references about each particular diagram.</p> <p>The right margin should be reserved for a \"Legend\" or \"Key\" that explains the semantics of any custom fonts, font weights, or colors used in each particular diagram. </p>"},{"location":"SequenceHome/#lifelines","title":"Lifelines","text":""},{"location":"SequenceHome/#naming-guidelines","title":"Naming Guidelines","text":"<p>Lifelines should have descriptive names that match the type of the objects they model. Use stereotypes as needed to clarify object types and avoid naming collisions as possible.</p>"},{"location":"SequenceHome/#layout-guidelines","title":"Layout Guidelines","text":"<p>As before, the recommended layout across the diagram is to arrange lifelines that start their activities earlier further to the left and proceed rightward. The temporal sequence within each lifeline proceeds top to bottom.</p>"},{"location":"SequenceHome/#messages","title":"Messages","text":""},{"location":"SequenceHome/#types-of-messages","title":"Types of Messages","text":"<p>Messages can represent physical actions by human users, function calls (local or remote), network messages, or inter-process communications. Thus the specific syntax of the message shown will vary.  Preferentially use prose descriptions when describing human actions and pseudocode when describing data exchange initiated and received by software or hardware devices.</p>"},{"location":"SequenceHome/#representing-object-lifecycles","title":"Representing Object Lifecycles","text":"<p>Explicit object creation and destruction should only be used when it makes the model clearer. In most cases, diagramming object destruction is unnecessary. However, showing the precise timing of object creation can be helpful and is indicated using the <code>&lt;&lt;create&gt;&gt;</code> stereotype.</p>"},{"location":"SequenceHome/#stereotypes","title":"Stereotypes","text":"<p>Some messages can refer back to use cases via the use of the <code>&lt;&lt;include&gt;&gt;</code> stereotype.</p>"},{"location":"SequenceHome/#further-layout-considerations","title":"Further Layout Considerations","text":"<p>Messages should be justified towards the arrowhead on the arrows in diagram.</p>"},{"location":"SequenceHome/#return-values","title":"Return Values","text":""},{"location":"SequenceHome/#when-to-include-return-values","title":"When to include Return Values","text":"<p>Return values are indicated by dashed arrows and should only be included when it is ambiguous what the type or value of the object being returned will be. </p>"},{"location":"SequenceHome/#types-as-return-values","title":"Types as Return Values","text":"<p>Return values can be simply the type of object being returned but if the specific return value is the salient element in deciding the next actions for the message receiver, return values can be listed as well.</p>"},{"location":"SequenceHome/#layout-considerations-formatting","title":"Layout Considerations &amp; Formatting","text":"<p>The return value should be justified towards the arrowhead on the arrows in diagram.</p>"},{"location":"SequenceHome/#conclusion","title":"Conclusion","text":"<p>Sequence diagrams represent an intermediate stage in design. They display more implementation details than Use Cases and are closer to the actual code. However, while they are useful in the design of message passing systems, such as multi-tier distributed systems, they are not suited for displaying complex branched logic or algorithms. These design elements are better left to State Diagrams and Activity Diagrams that are equipped to visualize those elements of data processing. </p>"},{"location":"SequenceHome/#references","title":"References","text":"<p>[1] The Elements of UML Style [2] How consistency is handled in model\u2011driven software engineering and UML: an expert opinion survey Software Quality Journal (2023) 31:1\u201354 https://doi.org/10.1007/s11219-022-09585-2 [3] OMG Systems Modeling Language (OMG SysML\u2122) Tutorial (September, 2009) [4] SYSML V2: Where We Are and How We Got Here (OMG Meeting Orlando, FL June 21, 2023)</p>"},{"location":"SysMLguideHome/","title":"Visual SysML Guidelines","text":""},{"location":"SysMLguideHome/#table-of-contents","title":"Table of Contents","text":"<p>Blah Blah</p>"},{"location":"UseCaseHome/","title":"Introduction","text":"<p>It is said that a picture is worth a 1000 words. It might be worth an order of magnitude more in lines of code since use cases represent system behaviors that occur at the interface of the human user and the computer system. Thus use cases describe the \"what\" in contrast to other diagrams which will describe the \"how.\" Thus the case diagram is a visual description of the overarching capabilities of a system and subsystem and an essential jumping off point for further refinement of the design.</p> <p>These guidelines are meant to comprise best practices for creating unambiguous Use Case diagrams that convey an accurate and comprehensive view of user interactions that can then be decomposed further and expanded into detailed designs for system implementation.</p> <p>This section will show concrete examples of what to do as well as what not to do accompanied with the justifications for the approach.</p>"},{"location":"UseCaseHome/#the-guidelines","title":"The Guidelines","text":""},{"location":"UseCaseHome/#use-case","title":"Use Case","text":""},{"location":"UseCaseHome/#naming-use-cases","title":"Naming Use Cases","text":"<p>Use case names should be straightforward in describing exactly what function is required from the system. As such, use case names should be verbs or verb phrases. When using verb phrases be sure to use active voice instead of passive voice. For example \"Compress Data\" instead of \"Perform Data Compression.\"</p> <p></p> <p>In Use Case Diagrams, use cases are written within oval shapes.</p>"},{"location":"UseCaseHome/#stacked-design-for-use-cases","title":"Stacked Design for Use Cases","text":"<p>Use case diagrams are not intended to show the time course of system operations or specify temporal dependencies between tasks. However, if the use cases on a particular diagram do have  a logical sequence they should be displayed as an aligned stack, in the correct order, to increase readability.</p>"},{"location":"UseCaseHome/#actor","title":"Actor","text":""},{"location":"UseCaseHome/#naming-actors","title":"Naming Actors","text":"<p>Actor names, should be unambiguous nouns.  It is OK, and actually preferable to use domain-specific terms to describe the actor as specifically as possible. Domain-relevant roles that directly map to actions described in use cases are preferred vs. general terms such as job titles. </p>"},{"location":"UseCaseHome/#actor-placement","title":"Actor Placement","text":"<p>Actors should be placed on the outside edges of the diagram while the use cases should be placed more centrally.  Actors should not be places unless they are associated with at least one use case on the diagram. </p>"},{"location":"UseCaseHome/#non-human-actors","title":"Non Human Actors","text":"<p>An actor is not necessarily a human. It could be an electronic component, or even an entire organization depending on the level of the diagram. Most Actors are drawn as stick figures but actions that are connected with a clear temporal signal such as a calendar event or a system clock are drawn with a stick-figure representation of an hour-glass.</p>"},{"location":"UseCaseHome/#relationship","title":"Relationship","text":""},{"location":"UseCaseHome/#types-of-relationships","title":"Types of Relationships","text":"<p>Use Cases diagrams may express several types of relationships. Relationships can be between two use cases two actors or between an actor and a use case. Use cases come in two basic types Associations, and Generalizations.</p>"},{"location":"UseCaseHome/#associations","title":"Associations","text":"<p>Associations between actors and use cases are undirected and are indicated by a single line between the actor and the use case without arrow heads. Associations between use case display the directionality of the relationship and are indicated by a single line with a terminal arrowhead. The arrowhead is open in style and direction of the arrow indicates that one use case invokes another and the arrow head points at the use case that is being invoked by the other.</p>"},{"location":"UseCaseHome/#generalizations","title":"Generalizations","text":"<p>Generalizations indicate that one type of actor or use case can be considered a subtype of another. The generalization is indicated by a single line with a terminal arrowhead. The arrowhead is closed (triangular) in style and the direction of the arrowhead points at the more general of the two types (e.g. the parent class).</p>"},{"location":"UseCaseHome/#extensions-vs-inclusions","title":"Extensions vs. Inclusions","text":"<p>Relationship arrows may be labeled to indicate one of two categories - extensions and inclusions. Extensions and inclusions are mean to indicate high level relationships and not design decisions. Thus avoid more than two levels of these relationships as that level of design is beyond the scope of a Use Case diagram.</p>"},{"location":"UseCaseHome/#extensions","title":"Extensions","text":"<p>Extensions are a type of generalization in which additional steps are performed beyond what is defined in the base case. An extension occurs after the invocation of the base case but may proceed in parallel with the actions of the base case. The extension relationship is indicated by the label <code>&lt;&lt;extend&gt;&gt;</code></p>"},{"location":"UseCaseHome/#inclusions","title":"Inclusions","text":"<p>Inclusions are a type of relationship in which one use case specifically invokes another in the course of performing its actions. An inclusion can be thought of similarly to a function call where one use case implies the usage of the other's functionality. The inclusion relationship is indicated by the label <code>&lt;&lt;include&gt;&gt;</code></p>"},{"location":"UseCaseHome/#layout-geometry","title":"Layout &amp; Geometry","text":"<p>The Use Case diagram is not an indicator of temporal sequencing. However if there is a natural ordering to the indicated activities, they should be placed top to bottom, left-to-right. The more important actors or prior use cases should appear above the others. An extending use case should be placed below the parent use case. The invoking use case should be placed to the left of the invoked use case. </p> <p>In addition to the best practices discussed here, certain publication requirements may need to be accommodated depending on the medium of publication or organizational standards. Additional additional formatting can be made compliant as follows.</p>"},{"location":"UseCaseHome/#headers-and-footers","title":"Headers and Footers","text":"<p>The diagram should be able to accommodate headers and footers.  The text of the headers and footers should be centered. The color and size of the footer should be configurable to comply with external publication requirements.</p>"},{"location":"UseCaseHome/#left-right-margins","title":"Left &amp; Right Margins","text":"<p>The left margin should be reserved for additional explanatory notes &amp; references about each particular diagram.</p> <p>The right margin should be reserved for a \"Legend\" or \"Key\" that explains the semantics of any custom fonts, font weights, or colors used in each particular diagram. </p>"},{"location":"UseCaseHome/#other-considerations","title":"Other Considerations","text":"<p>Do not model more detail than necessary and use high level concepts in a Use Case model. Natural Language descriptions and common-sense notions are preferred. Jargon and technical language is OK only if the target audience is expected to be familiar with all the terminology used.</p>"},{"location":"UseCaseHome/#system-boundary","title":"System Boundary","text":"<p>Use cases use rectangles to indicate various system boundaries. That is, use cases that are collected to implement the functionality of a named system.</p>"},{"location":"UseCaseHome/#when-to-not-use-boundaries","title":"When to (Not) Use Boundaries","text":"<p>System boundaries are optional and should only be used in cases where there are multiple systems or subsystems that need to be distinguished. If the use cases all belong to the same logical process, omit the system boundary as it will produced unnecessary clutter. </p>"},{"location":"UseCaseHome/#naming-considerations","title":"Naming Considerations","text":"<p>As with actors, the named system boundary should be a strong verb that indicates either the physical or logical system to which the member use cases belong.</p>"},{"location":"UseCaseHome/#lumping-splitting","title":"Lumping &amp; Splitting","text":"<p>Use a boundary box only if it would increase the clarity of the diagram and set apart meaningful distinctions between the use cases as collections. Remember that a Use Case diagram is not a detailed design. Thus what is considered a \"System\" is at the conceptual level and only indicates groupings between the use cases as it pertains to the services that the system provides to each type of user.  Avoid making distinctions with no functional visibility to the user and collect related actions based on their overall effects to the resulting outputs.</p>"},{"location":"UseCaseHome/#conclusion","title":"Conclusion","text":"<p>Just because the Use Case diagram describes high-level concepts it does not absolve them from being constructed in a rigorous fashion. On the contrary, design at this level must be managed with increased caution since misunderstandings conveyed from these diagrams to further elaborations of detailed design will be multiplied resulting in errors that will be both insidious and expensive to fix.</p>"},{"location":"UseCaseHome/#references","title":"References","text":"<p>[1] The Elements of UML Style [2] How consistency is handled in model\u2011driven software engineering and UML: an expert opinion survey Software Quality Journal (2023) 31:1\u201354 https://doi.org/10.1007/s11219-022-09585-2 [3] OMG Systems Modeling Language (OMG SysML\u2122) Tutorial (September, 2009) [4] SYSML V2: Where We Are and How We Got Here (OMG Meeting Orlando, FL June 21, 2023)</p>"}]}